/**
 * stdout
 * This file has been autogenerated using quicktype https://github.com/quicktype/quicktype - DO NOT EDIT
 * This file depends of https://github.com/DaveGamble/cJSON, https://github.com/joelguittet/c-list and https://github.com/joelguittet/c-hashtable
 * To parse json data from json string use the following: struct <type> * data = cJSON_Parse<type>(<string>);
 * To get json data from cJSON object use the following: struct <type> * data = cJSON_Get<type>Value(<cjson>);
 * To get cJSON object from json data use the following: cJSON * cjson = cJSON_Create<type>(<data>);
 * To print json string from json data use the following: char * string = cJSON_Print<type>(<data>);
 * To delete json data use the following: cJSON_Delete<type>(<data>);
 */

#ifndef LDTK_H
#define LDTK_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>

typedef struct cJSON cJSON;
#include <hashtable.h>
#include <list.h>

#ifndef cJSON_Bool
#define cJSON_Bool (cJSON_True | cJSON_False)
#endif
#ifndef cJSON_Map
#define cJSON_Map (1 << 16)
#endif
#ifndef cJSON_Enum
#define cJSON_Enum (1 << 17)
#endif

/**
 * Possible values: `Manual`, `AfterLoad`, `BeforeSave`, `AfterSave`
 */
enum When {
    WHEN_AFTER_LOAD,
    WHEN_AFTER_SAVE,
    WHEN_BEFORE_SAVE,
    WHEN_MANUAL,
};

struct LdtkCustomCommand {
    char * command;
    /**
     * Possible values: `Manual`, `AfterLoad`, `BeforeSave`, `AfterSave`
     */
    enum When when;
};

/**
 * Possible values: `Any`, `OnlySame`, `OnlyTags`, `OnlySpecificEntity`
 */
enum AllowedRefs {
    ALLOWEDREFS_ANY,
    ALLOWEDREFS_ONLY_SAME,
    ALLOWEDREFS_ONLY_SPECIFIC_ENTITY,
    ALLOWEDREFS_ONLY_TAGS,
};

/**
 * Possible values: `Hidden`, `ValueOnly`, `NameAndValue`, `EntityTile`, `LevelTile`,
 * `Points`, `PointStar`, `PointPath`, `PointPathLoop`, `RadiusPx`, `RadiusGrid`,
 * `ArrayCountWithLabel`, `ArrayCountNoLabel`, `RefLinkBetweenPivots`,
 * `RefLinkBetweenCenters`
 */
enum EditorDisplayMode {
    EDITORDISPLAYMODE_ARRAY_COUNT_NO_LABEL,
    EDITORDISPLAYMODE_ARRAY_COUNT_WITH_LABEL,
    EDITORDISPLAYMODE_ENTITY_TILE,
    EDITORDISPLAYMODE_HIDDEN,
    EDITORDISPLAYMODE_LEVEL_TILE,
    EDITORDISPLAYMODE_NAME_AND_VALUE,
    EDITORDISPLAYMODE_POINTS,
    EDITORDISPLAYMODE_POINT_PATH,
    EDITORDISPLAYMODE_POINT_PATH_LOOP,
    EDITORDISPLAYMODE_POINT_STAR,
    EDITORDISPLAYMODE_RADIUS_GRID,
    EDITORDISPLAYMODE_RADIUS_PX,
    EDITORDISPLAYMODE_REF_LINK_BETWEEN_CENTERS,
    EDITORDISPLAYMODE_REF_LINK_BETWEEN_PIVOTS,
    EDITORDISPLAYMODE_VALUE_ONLY,
};

/**
 * Possible values: `Above`, `Center`, `Beneath`
 */
enum EditorDisplayPos {
    EDITORDISPLAYPOS_ABOVE,
    EDITORDISPLAYPOS_BENEATH,
    EDITORDISPLAYPOS_CENTER,
};

/**
 * Possible values: `ZigZag`, `StraightArrow`, `CurvedArrow`, `ArrowsLine`, `DashedLine`
 */
enum EditorLinkStyle {
    EDITORLINKSTYLE_ARROWS_LINE,
    EDITORLINKSTYLE_CURVED_ARROW,
    EDITORLINKSTYLE_DASHED_LINE,
    EDITORLINKSTYLE_STRAIGHT_ARROW,
    EDITORLINKSTYLE_ZIG_ZAG,
};

enum TextLanguageMode {
    TEXTLANGUAGEMODE_LANG_C,
    TEXTLANGUAGEMODE_LANG_HAXE,
    TEXTLANGUAGEMODE_LANG_JS,
    TEXTLANGUAGEMODE_LANG_JSON,
    TEXTLANGUAGEMODE_LANG_LOG,
    TEXTLANGUAGEMODE_LANG_LUA,
    TEXTLANGUAGEMODE_LANG_MARKDOWN,
    TEXTLANGUAGEMODE_LANG_PYTHON,
    TEXTLANGUAGEMODE_LANG_RUBY,
    TEXTLANGUAGEMODE_LANG_XML,
};

/**
 * This section is mostly only intended for the LDtk editor app itself. You can safely
 * ignore it.
 */
struct FieldDefinition {
    /**
     * Human readable value type. Possible values: `Int, Float, String, Bool, Color,
     * ExternEnum.XXX, LocalEnum.XXX, Point, FilePath`.<br/>  If the field is an array, this
     * field will look like `Array<...>` (eg. `Array<Int>`, `Array<Point>` etc.)<br/>  NOTE: if
     * you enable the advanced option **Use Multilines type**, you will have "*Multilines*"
     * instead of "*String*" when relevant.
     */
    char * type;
    /**
     * Optional list of accepted file extensions for FilePath value type. Includes the dot:
     * `.ext`
     */
    list_t * accept_file_types;
    /**
     * Possible values: `Any`, `OnlySame`, `OnlyTags`, `OnlySpecificEntity`
     */
    enum AllowedRefs allowed_refs;
    int64_t * allowed_refs_entity_uid;
    list_t * allowed_ref_tags;
    bool allow_out_of_level_ref;
    /**
     * Array max length
     */
    int64_t * array_max_length;
    /**
     * Array min length
     */
    int64_t * array_min_length;
    bool auto_chain_ref;
    /**
     * TRUE if the value can be null. For arrays, TRUE means it can contain null values
     * (exception: array of Points can't have null values).
     */
    bool can_be_null;
    /**
     * Default value if selected value is null or invalid.
     */
    void * default_override;
    /**
     * User defined documentation for this field to provide help/tips to level designers about
     * accepted values.
     */
    char * doc;
    bool editor_always_show;
    bool editor_cut_long_values;
    char * editor_display_color;
    /**
     * Possible values: `Hidden`, `ValueOnly`, `NameAndValue`, `EntityTile`, `LevelTile`,
     * `Points`, `PointStar`, `PointPath`, `PointPathLoop`, `RadiusPx`, `RadiusGrid`,
     * `ArrayCountWithLabel`, `ArrayCountNoLabel`, `RefLinkBetweenPivots`,
     * `RefLinkBetweenCenters`
     */
    enum EditorDisplayMode editor_display_mode;
    /**
     * Possible values: `Above`, `Center`, `Beneath`
     */
    enum EditorDisplayPos editor_display_pos;
    double editor_display_scale;
    /**
     * Possible values: `ZigZag`, `StraightArrow`, `CurvedArrow`, `ArrowsLine`, `DashedLine`
     */
    enum EditorLinkStyle editor_link_style;
    bool editor_show_in_world;
    char * editor_text_prefix;
    char * editor_text_suffix;
    /**
     * User defined unique identifier
     */
    char * identifier;
    /**
     * TRUE if the value is an array of multiple values
     */
    bool is_array;
    /**
     * Max limit for value, if applicable
     */
    double * max;
    /**
     * Min limit for value, if applicable
     */
    double * min;
    /**
     * Optional regular expression that needs to be matched to accept values. Expected format:
     * `/some_reg_ex/g`, with optional "i" flag.
     */
    char * regex;
    bool symmetrical_ref;
    /**
     * Possible values: &lt;`null`&gt;, `LangPython`, `LangRuby`, `LangJS`, `LangLua`, `LangC`,
     * `LangHaxe`, `LangMarkdown`, `LangJson`, `LangXml`, `LangLog`
     */
    enum TextLanguageMode * text_language_mode;
    /**
     * UID of the tileset used for a Tile
     */
    int64_t * tileset_uid;
    /**
     * Internal enum representing the possible field types. Possible values: F_Int, F_Float,
     * F_String, F_Text, F_Bool, F_Color, F_Enum(...), F_Point, F_Path, F_EntityRef, F_Tile
     */
    char * field_definition_type;
    /**
     * Unique Int identifier
     */
    int64_t uid;
    /**
     * If TRUE, the color associated with this field will override the Entity or Level default
     * color in the editor UI. For Enum fields, this would be the color associated to their
     * values.
     */
    bool use_for_smart_color;
};

/**
 * Possible values: `DiscardOldOnes`, `PreventAdding`, `MoveLastOne`
 */
enum LimitBehavior {
    LIMITBEHAVIOR_DISCARD_OLD_ONES,
    LIMITBEHAVIOR_MOVE_LAST_ONE,
    LIMITBEHAVIOR_PREVENT_ADDING,
};

/**
 * If TRUE, the maxCount is a "per world" limit, if FALSE, it's a "per level". Possible
 * values: `PerLayer`, `PerLevel`, `PerWorld`
 */
enum LimitScope {
    LIMITSCOPE_PER_LAYER,
    LIMITSCOPE_PER_LEVEL,
    LIMITSCOPE_PER_WORLD,
};

/**
 * Possible values: `Rectangle`, `Ellipse`, `Tile`, `Cross`
 */
enum RenderMode {
    RENDERMODE_CROSS,
    RENDERMODE_ELLIPSE,
    RENDERMODE_RECTANGLE,
    RENDERMODE_TILE,
};

/**
 * This object represents a custom sub rectangle in a Tileset image.
 */
struct TilesetRectangle {
    /**
     * Height in pixels
     */
    int64_t h;
    /**
     * UID of the tileset
     */
    int64_t tileset_uid;
    /**
     * Width in pixels
     */
    int64_t w;
    /**
     * X pixels coordinate of the top-left corner in the Tileset image
     */
    int64_t x;
    /**
     * Y pixels coordinate of the top-left corner in the Tileset image
     */
    int64_t y;
};

/**
 * An enum describing how the the Entity tile is rendered inside the Entity bounds. Possible
 * values: `Cover`, `FitInside`, `Repeat`, `Stretch`, `FullSizeCropped`,
 * `FullSizeUncropped`, `NineSlice`
 */
enum TileRenderMode {
    TILERENDERMODE_COVER,
    TILERENDERMODE_FIT_INSIDE,
    TILERENDERMODE_FULL_SIZE_CROPPED,
    TILERENDERMODE_FULL_SIZE_UNCROPPED,
    TILERENDERMODE_NINE_SLICE,
    TILERENDERMODE_REPEAT,
    TILERENDERMODE_STRETCH,
};

struct EntityDefinition {
    /**
     * Base entity color
     */
    char * color;
    /**
     * User defined documentation for this element to provide help/tips to level designers.
     */
    char * doc;
    /**
     * If enabled, all instances of this entity will be listed in the project "Table of content"
     * object.
     */
    bool export_to_toc;
    /**
     * Array of field definitions
     */
    list_t * field_defs;
    double fill_opacity;
    /**
     * Pixel height
     */
    int64_t height;
    bool hollow;
    /**
     * User defined unique identifier
     */
    char * identifier;
    /**
     * Only applies to entities resizable on both X/Y. If TRUE, the entity instance width/height
     * will keep the same aspect ratio as the definition.
     */
    bool keep_aspect_ratio;
    /**
     * Possible values: `DiscardOldOnes`, `PreventAdding`, `MoveLastOne`
     */
    enum LimitBehavior limit_behavior;
    /**
     * If TRUE, the maxCount is a "per world" limit, if FALSE, it's a "per level". Possible
     * values: `PerLayer`, `PerLevel`, `PerWorld`
     */
    enum LimitScope limit_scope;
    double line_opacity;
    /**
     * Max instances count
     */
    int64_t max_count;
    /**
     * Max pixel height (only applies if the entity is resizable on Y)
     */
    int64_t * max_height;
    /**
     * Max pixel width (only applies if the entity is resizable on X)
     */
    int64_t * max_width;
    /**
     * Min pixel height (only applies if the entity is resizable on Y)
     */
    int64_t * min_height;
    /**
     * Min pixel width (only applies if the entity is resizable on X)
     */
    int64_t * min_width;
    /**
     * An array of 4 dimensions for the up/right/down/left borders (in this order) when using
     * 9-slice mode for `tileRenderMode`.<br/>  If the tileRenderMode is not NineSlice, then
     * this array is empty.<br/>  See: https://en.wikipedia.org/wiki/9-slice_scaling
     */
    list_t * nine_slice_borders;
    /**
     * Pivot X coordinate (from 0 to 1.0)
     */
    double pivot_x;
    /**
     * Pivot Y coordinate (from 0 to 1.0)
     */
    double pivot_y;
    /**
     * Possible values: `Rectangle`, `Ellipse`, `Tile`, `Cross`
     */
    enum RenderMode render_mode;
    /**
     * If TRUE, the entity instances will be resizable horizontally
     */
    bool resizable_x;
    /**
     * If TRUE, the entity instances will be resizable vertically
     */
    bool resizable_y;
    /**
     * Display entity name in editor
     */
    bool show_name;
    /**
     * An array of strings that classifies this entity
     */
    list_t * tags;
    /**
     * **WARNING**: this deprecated value is no longer exported since version 1.2.0  Replaced
     * by: `tileRect`
     */
    int64_t * tile_id;
    double tile_opacity;
    /**
     * An object representing a rectangle from an existing Tileset
     */
    struct TilesetRectangle * tile_rect;
    /**
     * An enum describing how the the Entity tile is rendered inside the Entity bounds. Possible
     * values: `Cover`, `FitInside`, `Repeat`, `Stretch`, `FullSizeCropped`,
     * `FullSizeUncropped`, `NineSlice`
     */
    enum TileRenderMode tile_render_mode;
    /**
     * Tileset ID used for optional tile display
     */
    int64_t * tileset_id;
    /**
     * Unique Int identifier
     */
    int64_t uid;
    /**
     * This tile overrides the one defined in `tileRect` in the UI
     */
    struct TilesetRectangle * ui_tile_rect;
    /**
     * Pixel width
     */
    int64_t width;
};

struct EnumValueDefinition {
    /**
     * **WARNING**: this deprecated value is no longer exported since version 1.4.0  Replaced
     * by: `tileRect`
     */
    list_t * tile_src_rect;
    /**
     * Optional color
     */
    int64_t color;
    /**
     * Enum value
     */
    char * id;
    /**
     * **WARNING**: this deprecated value is no longer exported since version 1.4.0  Replaced
     * by: `tileRect`
     */
    int64_t * tile_id;
    /**
     * Optional tileset rectangle to represents this value
     */
    struct TilesetRectangle * tile_rect;
};

struct EnumDefinition {
    char * external_file_checksum;
    /**
     * Relative path to the external file providing this Enum
     */
    char * external_rel_path;
    /**
     * Tileset UID if provided
     */
    int64_t * icon_tileset_uid;
    /**
     * User defined unique identifier
     */
    char * identifier;
    /**
     * An array of user-defined tags to organize the Enums
     */
    list_t * tags;
    /**
     * Unique Int identifier
     */
    int64_t uid;
    /**
     * All possible enum values, with their optional Tile infos.
     */
    list_t * values;
};

/**
 * Checker mode Possible values: `None`, `Horizontal`, `Vertical`
 */
enum Checker {
    CHECKER_HORIZONTAL,
    CHECKER_NONE,
    CHECKER_VERTICAL,
};

/**
 * Defines how tileIds array is used Possible values: `Single`, `Stamp`
 */
enum TileMode {
    TILEMODE_SINGLE,
    TILEMODE_STAMP,
};

/**
 * This complex section isn't meant to be used by game devs at all, as these rules are
 * completely resolved internally by the editor before any saving. You should just ignore
 * this part.
 */
struct AutoLayerRuleDefinition {
    /**
     * If FALSE, the rule effect isn't applied, and no tiles are generated.
     */
    bool active;
    double alpha;
    /**
     * When TRUE, the rule will prevent other rules to be applied in the same cell if it matches
     * (TRUE by default).
     */
    bool break_on_match;
    /**
     * Chances for this rule to be applied (0 to 1)
     */
    double chance;
    /**
     * Checker mode Possible values: `None`, `Horizontal`, `Vertical`
     */
    enum Checker checker;
    /**
     * If TRUE, allow rule to be matched by flipping its pattern horizontally
     */
    bool flip_x;
    /**
     * If TRUE, allow rule to be matched by flipping its pattern vertically
     */
    bool flip_y;
    /**
     * Default IntGrid value when checking cells outside of level bounds
     */
    int64_t * out_of_bounds_value;
    /**
     * Rule pattern (size x size)
     */
    list_t * pattern;
    /**
     * If TRUE, enable Perlin filtering to only apply rule on specific random area
     */
    bool perlin_active;
    double perlin_octaves;
    double perlin_scale;
    double perlin_seed;
    /**
     * X pivot of a tile stamp (0-1)
     */
    double pivot_x;
    /**
     * Y pivot of a tile stamp (0-1)
     */
    double pivot_y;
    /**
     * Pattern width & height. Should only be 1,3,5 or 7.
     */
    int64_t size;
    /**
     * Array of all the tile IDs. They are used randomly or as stamps, based on `tileMode` value.
     */
    list_t * tile_ids;
    /**
     * Defines how tileIds array is used Possible values: `Single`, `Stamp`
     */
    enum TileMode tile_mode;
    /**
     * Max random offset for X tile pos
     */
    int64_t tile_random_x_max;
    /**
     * Min random offset for X tile pos
     */
    int64_t tile_random_x_min;
    /**
     * Max random offset for Y tile pos
     */
    int64_t tile_random_y_max;
    /**
     * Min random offset for Y tile pos
     */
    int64_t tile_random_y_min;
    /**
     * Tile X offset
     */
    int64_t tile_x_offset;
    /**
     * Tile Y offset
     */
    int64_t tile_y_offset;
    /**
     * Unique Int identifier
     */
    int64_t uid;
    /**
     * X cell coord modulo
     */
    int64_t x_modulo;
    /**
     * X cell start offset
     */
    int64_t x_offset;
    /**
     * Y cell coord modulo
     */
    int64_t y_modulo;
    /**
     * Y cell start offset
     */
    int64_t y_offset;
};

struct AutoLayerRuleGroup {
    bool active;
    /**
     * *This field was removed in 1.0.0 and should no longer be used.*
     */
    bool * collapsed;
    char * color;
    struct TilesetRectangle * icon;
    bool is_optional;
    char * name;
    list_t * rules;
    int64_t uid;
    bool uses_wizard;
};

/**
 * IntGrid value definition
 */
struct IntGridValueDefinition {
    char * color;
    /**
     * Parent group identifier (0 if none)
     */
    int64_t group_uid;
    /**
     * User defined unique identifier
     */
    char * identifier;
    struct TilesetRectangle * tile;
    /**
     * The IntGrid value itself
     */
    int64_t value;
};

/**
 * IntGrid value group definition
 */
struct IntGridValueGroupDefinition {
    /**
     * User defined color
     */
    char * color;
    /**
     * User defined string identifier
     */
    char * identifier;
    /**
     * Group unique ID
     */
    int64_t uid;
};

/**
 * Type of the layer as Haxe Enum Possible values: `IntGrid`, `Entities`, `Tiles`,
 * `AutoLayer`
 */
enum Type {
    TYPE_AUTO_LAYER,
    TYPE_ENTITIES,
    TYPE_INT_GRID,
    TYPE_TILES,
};

struct LayerDefinition {
    /**
     * Type of the layer (*IntGrid, Entities, Tiles or AutoLayer*)
     */
    char * type;
    /**
     * Contains all the auto-layer rule definitions.
     */
    list_t * auto_rule_groups;
    int64_t * auto_source_layer_def_uid;
    /**
     * **WARNING**: this deprecated value is no longer exported since version 1.2.0  Replaced
     * by: `tilesetDefUid`
     */
    int64_t * auto_tileset_def_uid;
    /**
     * Allow editor selections when the layer is not currently active.
     */
    bool can_select_when_inactive;
    /**
     * Opacity of the layer (0 to 1.0)
     */
    double display_opacity;
    /**
     * User defined documentation for this element to provide help/tips to level designers.
     */
    char * doc;
    /**
     * An array of tags to forbid some Entities in this layer
     */
    list_t * excluded_tags;
    /**
     * Width and height of the grid in pixels
     */
    int64_t grid_size;
    /**
     * Height of the optional "guide" grid in pixels
     */
    int64_t guide_grid_hei;
    /**
     * Width of the optional "guide" grid in pixels
     */
    int64_t guide_grid_wid;
    bool hide_fields_when_inactive;
    /**
     * Hide the layer from the list on the side of the editor view.
     */
    bool hide_in_list;
    /**
     * User defined unique identifier
     */
    char * identifier;
    /**
     * Alpha of this layer when it is not the active one.
     */
    double inactive_opacity;
    /**
     * An array that defines extra optional info for each IntGrid value.<br/>  WARNING: the
     * array order is not related to actual IntGrid values! As user can re-order IntGrid values
     * freely, you may value "2" before value "1" in this array.
     */
    list_t * int_grid_values;
    /**
     * Group informations for IntGrid values
     */
    list_t * int_grid_values_groups;
    /**
     * Parallax horizontal factor (from -1 to 1, defaults to 0) which affects the scrolling
     * speed of this layer, creating a fake 3D (parallax) effect.
     */
    double parallax_factor_x;
    /**
     * Parallax vertical factor (from -1 to 1, defaults to 0) which affects the scrolling speed
     * of this layer, creating a fake 3D (parallax) effect.
     */
    double parallax_factor_y;
    /**
     * If true (default), a layer with a parallax factor will also be scaled up/down accordingly.
     */
    bool parallax_scaling;
    /**
     * X offset of the layer, in pixels (IMPORTANT: this should be added to the `LayerInstance`
     * optional offset)
     */
    int64_t px_offset_x;
    /**
     * Y offset of the layer, in pixels (IMPORTANT: this should be added to the `LayerInstance`
     * optional offset)
     */
    int64_t px_offset_y;
    /**
     * If TRUE, the content of this layer will be used when rendering levels in a simplified way
     * for the world view
     */
    bool render_in_world_view;
    /**
     * An array of tags to filter Entities that can be added to this layer
     */
    list_t * required_tags;
    /**
     * If the tiles are smaller or larger than the layer grid, the pivot value will be used to
     * position the tile relatively its grid cell.
     */
    double tile_pivot_x;
    /**
     * If the tiles are smaller or larger than the layer grid, the pivot value will be used to
     * position the tile relatively its grid cell.
     */
    double tile_pivot_y;
    /**
     * Reference to the default Tileset UID being used by this layer definition.<br/>
     * **WARNING**: some layer *instances* might use a different tileset. So most of the time,
     * you should probably use the `__tilesetDefUid` value found in layer instances.<br/>  Note:
     * since version 1.0.0, the old `autoTilesetDefUid` was removed and merged into this value.
     */
    int64_t * tileset_def_uid;
    /**
     * Type of the layer as Haxe Enum Possible values: `IntGrid`, `Entities`, `Tiles`,
     * `AutoLayer`
     */
    enum Type layer_definition_type;
    /**
     * User defined color for the UI
     */
    char * ui_color;
    /**
     * Unique Int identifier
     */
    int64_t uid;
};

/**
 * In a tileset definition, user defined meta-data of a tile.
 */
struct TileCustomMetadata {
    char * data;
    int64_t tile_id;
};

enum EmbedAtlas {
    EMBEDATLAS_LDTK_ICONS,
};

/**
 * In a tileset definition, enum based tag infos
 */
struct EnumTagValue {
    char * enum_value_id;
    list_t * tile_ids;
};

/**
 * The `Tileset` definition is the most important part among project definitions. It
 * contains some extra informations about each integrated tileset. If you only had to parse
 * one definition section, that would be the one.
 */
struct TilesetDefinition {
    /**
     * Grid-based height
     */
    int64_t c_hei;
    /**
     * Grid-based width
     */
    int64_t c_wid;
    /**
     * The following data is used internally for various optimizations. It's always synced with
     * source image changes.
     */
    hashtable_t * cached_pixel_data;
    /**
     * An array of custom tile metadata
     */
    list_t * custom_data;
    /**
     * If this value is set, then it means that this atlas uses an internal LDtk atlas image
     * instead of a loaded one. Possible values: &lt;`null`&gt;, `LdtkIcons`
     */
    enum EmbedAtlas * embed_atlas;
    /**
     * Tileset tags using Enum values specified by `tagsSourceEnumId`. This array contains 1
     * element per Enum value, which contains an array of all Tile IDs that are tagged with it.
     */
    list_t * enum_tags;
    /**
     * User defined unique identifier
     */
    char * identifier;
    /**
     * Distance in pixels from image borders
     */
    int64_t padding;
    /**
     * Image height in pixels
     */
    int64_t px_hei;
    /**
     * Image width in pixels
     */
    int64_t px_wid;
    /**
     * Path to the source file, relative to the current project JSON file<br/>  It can be null
     * if no image was provided, or when using an embed atlas.
     */
    char * rel_path;
    /**
     * Array of group of tiles selections, only meant to be used in the editor
     */
    list_t * saved_selections;
    /**
     * Space in pixels between all tiles
     */
    int64_t spacing;
    /**
     * An array of user-defined tags to organize the Tilesets
     */
    list_t * tags;
    /**
     * Optional Enum definition UID used for this tileset meta-data
     */
    int64_t * tags_source_enum_uid;
    int64_t tile_grid_size;
    /**
     * Unique Intidentifier
     */
    int64_t uid;
};

/**
 * If you're writing your own LDtk importer, you should probably just ignore *most* stuff in
 * the `defs` section, as it contains data that are mostly important to the editor. To keep
 * you away from the `defs` section and avoid some unnecessary JSON parsing, important data
 * from definitions is often duplicated in fields prefixed with a double underscore (eg.
 * `__identifier` or `__type`).  The 2 only definition types you might need here are
 * **Tilesets** and **Enums**.
 *
 * A structure containing all the definitions of this project
 */
struct Definitions {
    /**
     * All entities definitions, including their custom fields
     */
    list_t * entities;
    /**
     * All internal enums
     */
    list_t * enums;
    /**
     * Note: external enums are exactly the same as `enums`, except they have a `relPath` to
     * point to an external source file.
     */
    list_t * external_enums;
    /**
     * All layer definitions
     */
    list_t * layers;
    /**
     * All custom fields available to all levels.
     */
    list_t * level_fields;
    /**
     * All tilesets
     */
    list_t * tilesets;
};

enum Flag {
    FLAG_DISCARD_PRE_CSV_INT_GRID,
    FLAG_EXPORT_PRE_CSV_INT_GRID_FORMAT,
    FLAG_IGNORE_BACKUP_SUGGEST,
    FLAG_MULTI_WORLDS,
    FLAG_PREPEND_INDEX_TO_LEVEL_FILE_NAMES,
    FLAG_USE_MULTILINES_TYPE,
};

struct FieldInstance {
    /**
     * Field definition identifier
     */
    char * identifier;
    /**
     * Optional TilesetRect used to display this field (this can be the field own Tile, or some
     * other Tile guessed from the value, like an Enum).
     */
    struct TilesetRectangle * tile;
    /**
     * Type of the field, such as `Int`, `Float`, `String`, `Enum(my_enum_name)`, `Bool`,
     * etc.<br/>  NOTE: if you enable the advanced option **Use Multilines type**, you will have
     * "*Multilines*" instead of "*String*" when relevant.
     */
    char * type;
    /**
     * Actual value of the field instance. The value type varies, depending on `__type`:<br/>
     * - For **classic types** (ie. Integer, Float, Boolean, String, Text and FilePath), you
     * just get the actual value with the expected type.<br/>   - For **Color**, the value is an
     * hexadecimal string using "#rrggbb" format.<br/>   - For **Enum**, the value is a String
     * representing the selected enum value.<br/>   - For **Point**, the value is a
     * [GridPoint](#ldtk-GridPoint) object.<br/>   - For **Tile**, the value is a
     * [TilesetRect](#ldtk-TilesetRect) object.<br/>   - For **EntityRef**, the value is an
     * [EntityReferenceInfos](#ldtk-EntityReferenceInfos) object.<br/><br/>  If the field is an
     * array, then this `__value` will also be a JSON array.
     */
    void * value;
    /**
     * Reference of the **Field definition** UID
     */
    int64_t def_uid;
    /**
     * Editor internal raw values
     */
    list_t * real_editor_values;
};

struct EntityInstance {
    /**
     * Grid-based coordinates (`[x,y]` format)
     */
    list_t * grid;
    /**
     * Entity definition identifier
     */
    char * identifier;
    /**
     * Pivot coordinates  (`[x,y]` format, values are from 0 to 1) of the Entity
     */
    list_t * pivot;
    /**
     * The entity "smart" color, guessed from either Entity definition, or one its field
     * instances.
     */
    char * smart_color;
    /**
     * Array of tags defined in this Entity definition
     */
    list_t * tags;
    /**
     * Optional TilesetRect used to display this entity (it could either be the default Entity
     * tile, or some tile provided by a field value, like an Enum).
     */
    struct TilesetRectangle * tile;
    /**
     * X world coordinate in pixels
     */
    int64_t world_x;
    /**
     * Y world coordinate in pixels
     */
    int64_t world_y;
    /**
     * Reference of the **Entity definition** UID
     */
    int64_t def_uid;
    /**
     * An array of all custom fields and their values.
     */
    list_t * field_instances;
    /**
     * Entity height in pixels. For non-resizable entities, it will be the same as Entity
     * definition.
     */
    int64_t height;
    /**
     * Unique instance identifier
     */
    char * iid;
    /**
     * Pixel coordinates (`[x,y]` format) in current level coordinate space. Don't forget
     * optional layer offsets, if they exist!
     */
    list_t * px;
    /**
     * Entity width in pixels. For non-resizable entities, it will be the same as Entity
     * definition.
     */
    int64_t width;
};

/**
 * This object describes the "location" of an Entity instance in the project worlds.
 */
struct ReferenceToAnEntityInstance {
    /**
     * IID of the refered EntityInstance
     */
    char * entity_iid;
    /**
     * IID of the LayerInstance containing the refered EntityInstance
     */
    char * layer_iid;
    /**
     * IID of the Level containing the refered EntityInstance
     */
    char * level_iid;
    /**
     * IID of the World containing the refered EntityInstance
     */
    char * world_iid;
};

/**
 * This object is just a grid-based coordinate used in Field values.
 */
struct GridPoint {
    /**
     * X grid-based coordinate
     */
    int64_t cx;
    /**
     * Y grid-based coordinate
     */
    int64_t cy;
};

/**
 * IntGrid value instance
 */
struct IntGridValueInstance {
    /**
     * Coordinate ID in the layer grid
     */
    int64_t coord_id;
    /**
     * IntGrid value
     */
    int64_t v;
};

/**
 * This structure represents a single tile from a given Tileset.
 */
struct TileInstance {
    /**
     * Alpha/opacity of the tile (0-1, defaults to 1)
     */
    double a;
    /**
     * Internal data used by the editor.<br/>  For auto-layer tiles: `[ruleId, coordId]`.<br/>
     * For tile-layer tiles: `[coordId]`.
     */
    list_t * d;
    /**
     * "Flip bits", a 2-bits integer to represent the mirror transformations of the tile.<br/>
     * - Bit 0 = X flip<br/>   - Bit 1 = Y flip<br/>   Examples: f=0 (no flip), f=1 (X flip
     * only), f=2 (Y flip only), f=3 (both flips)
     */
    int64_t f;
    /**
     * Pixel coordinates of the tile in the **layer** (`[x,y]` format). Don't forget optional
     * layer offsets, if they exist!
     */
    list_t * px;
    /**
     * Pixel coordinates of the tile in the **tileset** (`[x,y]` format)
     */
    list_t * src;
    /**
     * The *Tile ID* in the corresponding tileset.
     */
    int64_t t;
};

struct LayerInstance {
    /**
     * Grid-based height
     */
    int64_t c_hei;
    /**
     * Grid-based width
     */
    int64_t c_wid;
    /**
     * Grid size
     */
    int64_t grid_size;
    /**
     * Layer definition identifier
     */
    char * identifier;
    /**
     * Layer opacity as Float [0-1]
     */
    double opacity;
    /**
     * Total layer X pixel offset, including both instance and definition offsets.
     */
    int64_t px_total_offset_x;
    /**
     * Total layer Y pixel offset, including both instance and definition offsets.
     */
    int64_t px_total_offset_y;
    /**
     * The definition UID of corresponding Tileset, if any.
     */
    int64_t * tileset_def_uid;
    /**
     * The relative path to corresponding Tileset, if any.
     */
    char * tileset_rel_path;
    /**
     * Layer type (possible values: IntGrid, Entities, Tiles or AutoLayer)
     */
    char * type;
    /**
     * An array containing all tiles generated by Auto-layer rules. The array is already sorted
     * in display order (ie. 1st tile is beneath 2nd, which is beneath 3rd etc.).<br/><br/>
     * Note: if multiple tiles are stacked in the same cell as the result of different rules,
     * all tiles behind opaque ones will be discarded.
     */
    list_t * auto_layer_tiles;
    list_t * entity_instances;
    list_t * grid_tiles;
    /**
     * Unique layer instance identifier
     */
    char * iid;
    /**
     * **WARNING**: this deprecated value is no longer exported since version 1.0.0  Replaced
     * by: `intGridCsv`
     */
    list_t * int_grid;
    /**
     * A list of all values in the IntGrid layer, stored in CSV format (Comma Separated
     * Values).<br/>  Order is from left to right, and top to bottom (ie. first row from left to
     * right, followed by second row, etc).<br/>  `0` means "empty cell" and IntGrid values
     * start at 1.<br/>  The array size is `__cWid` x `__cHei` cells.
     */
    list_t * int_grid_csv;
    /**
     * Reference the Layer definition UID
     */
    int64_t layer_def_uid;
    /**
     * Reference to the UID of the level containing this layer instance
     */
    int64_t level_id;
    /**
     * An Array containing the UIDs of optional rules that were enabled in this specific layer
     * instance.
     */
    list_t * optional_rules;
    /**
     * This layer can use another tileset by overriding the tileset UID here.
     */
    int64_t * override_tileset_uid;
    /**
     * X offset in pixels to render this layer, usually 0 (IMPORTANT: this should be added to
     * the `LayerDef` optional offset, so you should probably prefer using `__pxTotalOffsetX`
     * which contains the total offset value)
     */
    int64_t px_offset_x;
    /**
     * Y offset in pixels to render this layer, usually 0 (IMPORTANT: this should be added to
     * the `LayerDef` optional offset, so you should probably prefer using `__pxTotalOffsetX`
     * which contains the total offset value)
     */
    int64_t px_offset_y;
    /**
     * Random seed used for Auto-Layers rendering
     */
    int64_t seed;
    /**
     * Layer instance visibility
     */
    bool visible;
};

/**
 * Level background image position info
 */
struct LevelBackgroundPosition {
    /**
     * An array of 4 float values describing the cropped sub-rectangle of the displayed
     * background image. This cropping happens when original is larger than the level bounds.
     * Array format: `[ cropX, cropY, cropWidth, cropHeight ]`
     */
    list_t * crop_rect;
    /**
     * An array containing the `[scaleX,scaleY]` values of the **cropped** background image,
     * depending on `bgPos` option.
     */
    list_t * scale;
    /**
     * An array containing the `[x,y]` pixel coordinates of the top-left corner of the
     * **cropped** background image, depending on `bgPos` option.
     */
    list_t * top_left_px;
};

enum BgPos {
    BGPOS_CONTAIN,
    BGPOS_COVER,
    BGPOS_COVER_DIRTY,
    BGPOS_REPEAT,
    BGPOS_UNSCALED,
};

/**
 * Nearby level info
 */
struct NeighbourLevel {
    /**
     * A single lowercase character tipping on the level location (`n`orth, `s`outh, `w`est,
     * `e`ast).<br/>  Since 1.4.0, this character value can also be `<` (neighbour depth is
     * lower), `>` (neighbour depth is greater) or `o` (levels overlap and share the same world
     * depth).
     */
    char * dir;
    /**
     * Neighbour Instance Identifier
     */
    char * level_iid;
    /**
     * **WARNING**: this deprecated value is no longer exported since version 1.2.0  Replaced
     * by: `levelIid`
     */
    int64_t * level_uid;
};

/**
 * This section contains all the level data. It can be found in 2 distinct forms, depending
 * on Project current settings:  - If "*Separate level files*" is **disabled** (default):
 * full level data is *embedded* inside the main Project JSON file, - If "*Separate level
 * files*" is **enabled**: level data is stored in *separate* standalone `.ldtkl` files (one
 * per level). In this case, the main Project JSON file will still contain most level data,
 * except heavy sections, like the `layerInstances` array (which will be null). The
 * `externalRelPath` string points to the `ldtkl` file.  A `ldtkl` file is just a JSON file
 * containing exactly what is described below.
 */
struct Level {
    /**
     * Background color of the level (same as `bgColor`, except the default value is
     * automatically used here if its value is `null`)
     */
    char * bg_color;
    /**
     * Position informations of the background image, if there is one.
     */
    struct LevelBackgroundPosition * bg_pos;
    /**
     * An array listing all other levels touching this one on the world map. Since 1.4.0, this
     * includes levels that overlap in the same world layer, or in nearby world layers.<br/>
     * Only relevant for world layouts where level spatial positioning is manual (ie. GridVania,
     * Free). For Horizontal and Vertical layouts, this array is always empty.
     */
    list_t * neighbours;
    /**
     * The "guessed" color for this level in the editor, decided using either the background
     * color or an existing custom field.
     */
    char * smart_color;
    /**
     * Background color of the level. If `null`, the project `defaultLevelBgColor` should be
     * used.
     */
    char * level_bg_color;
    /**
     * Background image X pivot (0-1)
     */
    double bg_pivot_x;
    /**
     * Background image Y pivot (0-1)
     */
    double bg_pivot_y;
    /**
     * An enum defining the way the background image (if any) is positioned on the level. See
     * `__bgPos` for resulting position info. Possible values: &lt;`null`&gt;, `Unscaled`,
     * `Contain`, `Cover`, `CoverDirty`, `Repeat`
     */
    enum BgPos * level_bg_pos;
    /**
     * The *optional* relative path to the level background image.
     */
    char * bg_rel_path;
    /**
     * This value is not null if the project option "*Save levels separately*" is enabled. In
     * this case, this **relative** path points to the level Json file.
     */
    char * external_rel_path;
    /**
     * An array containing this level custom field values.
     */
    list_t * field_instances;
    /**
     * User defined unique identifier
     */
    char * identifier;
    /**
     * Unique instance identifier
     */
    char * iid;
    /**
     * An array containing all Layer instances. **IMPORTANT**: if the project option "*Save
     * levels separately*" is enabled, this field will be `null`.<br/>  This array is **sorted
     * in display order**: the 1st layer is the top-most and the last is behind.
     */
    list_t * layer_instances;
    /**
     * Height of the level in pixels
     */
    int64_t px_hei;
    /**
     * Width of the level in pixels
     */
    int64_t px_wid;
    /**
     * Unique Int identifier
     */
    int64_t uid;
    /**
     * If TRUE, the level identifier will always automatically use the naming pattern as defined
     * in `Project.levelNamePattern`. Becomes FALSE if the identifier is manually modified by
     * user.
     */
    bool use_auto_identifier;
    /**
     * Index that represents the "depth" of the level in the world. Default is 0, greater means
     * "above", lower means "below".<br/>  This value is mostly used for display only and is
     * intended to make stacking of levels easier to manage.
     */
    int64_t world_depth;
    /**
     * World X coordinate in pixels.<br/>  Only relevant for world layouts where level spatial
     * positioning is manual (ie. GridVania, Free). For Horizontal and Vertical layouts, the
     * value is always -1 here.
     */
    int64_t world_x;
    /**
     * World Y coordinate in pixels.<br/>  Only relevant for world layouts where level spatial
     * positioning is manual (ie. GridVania, Free). For Horizontal and Vertical layouts, the
     * value is always -1 here.
     */
    int64_t world_y;
};

struct LdtkTableOfContentEntry {
    char * identifier;
    list_t * instances;
};

enum WorldLayout {
    WORLDLAYOUT_FREE,
    WORLDLAYOUT_GRID_VANIA,
    WORLDLAYOUT_LINEAR_HORIZONTAL,
    WORLDLAYOUT_LINEAR_VERTICAL,
};

/**
 * **IMPORTANT**: this type is available as a preview. You can rely on it to update your
 * importers, for when it will be officially available.  A World contains multiple levels,
 * and it has its own layout settings.
 */
struct World {
    /**
     * Default new level height
     */
    int64_t default_level_height;
    /**
     * Default new level width
     */
    int64_t default_level_width;
    /**
     * User defined unique identifier
     */
    char * identifier;
    /**
     * Unique instance identifer
     */
    char * iid;
    /**
     * All levels from this world. The order of this array is only relevant in
     * `LinearHorizontal` and `linearVertical` world layouts (see `worldLayout` value).
     * Otherwise, you should refer to the `worldX`,`worldY` coordinates of each Level.
     */
    list_t * levels;
    /**
     * Height of the world grid in pixels.
     */
    int64_t world_grid_height;
    /**
     * Width of the world grid in pixels.
     */
    int64_t world_grid_width;
    /**
     * An enum that describes how levels are organized in this project (ie. linearly or in a 2D
     * space). Possible values: `Free`, `GridVania`, `LinearHorizontal`, `LinearVertical`, `null`
     */
    enum WorldLayout * world_layout;
};

/**
 * This object is not actually used by LDtk. It ONLY exists to force explicit references to
 * all types, to make sure QuickType finds them and integrate all of them. Otherwise,
 * Quicktype will drop types that are not explicitely used.
 */
struct ForcedRefs {
    struct AutoLayerRuleGroup * auto_layer_rule_group;
    struct AutoLayerRuleDefinition * auto_rule_def;
    struct LdtkCustomCommand * custom_command;
    struct Definitions * definitions;
    struct EntityDefinition * entity_def;
    struct EntityInstance * entity_instance;
    struct ReferenceToAnEntityInstance * entity_reference_infos;
    struct EnumDefinition * enum_def;
    struct EnumValueDefinition * enum_def_values;
    struct EnumTagValue * enum_tag_value;
    struct FieldDefinition * field_def;
    struct FieldInstance * field_instance;
    struct GridPoint * grid_point;
    struct IntGridValueDefinition * int_grid_value_def;
    struct IntGridValueGroupDefinition * int_grid_value_group_def;
    struct IntGridValueInstance * int_grid_value_instance;
    struct LayerDefinition * layer_def;
    struct LayerInstance * layer_instance;
    struct Level * level;
    struct LevelBackgroundPosition * level_bg_pos_infos;
    struct NeighbourLevel * neighbour_level;
    struct LdtkTableOfContentEntry * table_of_content_entry;
    struct TileInstance * tile;
    struct TileCustomMetadata * tile_custom_metadata;
    struct TilesetDefinition * tileset_def;
    struct TilesetRectangle * tileset_rect;
    struct World * world;
};

/**
 * Naming convention for Identifiers (first-letter uppercase, full uppercase etc.) Possible
 * values: `Capitalize`, `Uppercase`, `Lowercase`, `Free`
 */
enum IdentifierStyle {
    IDENTIFIERSTYLE_CAPITALIZE,
    IDENTIFIERSTYLE_FREE,
    IDENTIFIERSTYLE_LOWERCASE,
    IDENTIFIERSTYLE_UPPERCASE,
};

/**
 * "Image export" option when saving project. Possible values: `None`, `OneImagePerLayer`,
 * `OneImagePerLevel`, `LayersAndLevels`
 */
enum ImageExportMode {
    IMAGEEXPORTMODE_LAYERS_AND_LEVELS,
    IMAGEEXPORTMODE_NONE,
    IMAGEEXPORTMODE_ONE_IMAGE_PER_LAYER,
    IMAGEEXPORTMODE_ONE_IMAGE_PER_LEVEL,
};

/**
 * This file is a JSON schema of files created by LDtk level editor (https://ldtk.io).
 *
 * This is the root of any Project JSON file. It contains:  - the project settings, - an
 * array of levels, - a group of definitions (that can probably be safely ignored for most
 * users).
 */
struct LDtk {
    /**
     * This object is not actually used by LDtk. It ONLY exists to force explicit references to
     * all types, to make sure QuickType finds them and integrate all of them. Otherwise,
     * Quicktype will drop types that are not explicitely used.
     */
    struct ForcedRefs * forced_refs;
    /**
     * LDtk application build identifier.<br/>  This is only used to identify the LDtk version
     * that generated this particular project file, which can be useful for specific bug fixing.
     * Note that the build identifier is just the date of the release, so it's not unique to
     * each user (one single global ID per LDtk public release), and as a result, completely
     * anonymous.
     */
    double app_build_id;
    /**
     * Number of backup files to keep, if the `backupOnSave` is TRUE
     */
    int64_t backup_limit;
    /**
     * If TRUE, an extra copy of the project will be created in a sub folder, when saving.
     */
    bool backup_on_save;
    /**
     * Target relative path to store backup files
     */
    char * backup_rel_path;
    /**
     * Project background color
     */
    char * bg_color;
    /**
     * An array of command lines that can be ran manually by the user
     */
    list_t * custom_commands;
    /**
     * Default height for new entities
     */
    int64_t default_entity_height;
    /**
     * Default width for new entities
     */
    int64_t default_entity_width;
    /**
     * Default grid size for new layers
     */
    int64_t default_grid_size;
    /**
     * Default background color of levels
     */
    char * default_level_bg_color;
    /**
     * **WARNING**: this field will move to the `worlds` array after the "multi-worlds" update.
     * It will then be `null`. You can enable the Multi-worlds advanced project option to enable
     * the change immediately.<br/><br/>  Default new level height
     */
    int64_t * default_level_height;
    /**
     * **WARNING**: this field will move to the `worlds` array after the "multi-worlds" update.
     * It will then be `null`. You can enable the Multi-worlds advanced project option to enable
     * the change immediately.<br/><br/>  Default new level width
     */
    int64_t * default_level_width;
    /**
     * Default X pivot (0 to 1) for new entities
     */
    double default_pivot_x;
    /**
     * Default Y pivot (0 to 1) for new entities
     */
    double default_pivot_y;
    /**
     * A structure containing all the definitions of this project
     */
    struct Definitions * defs;
    /**
     * If the project isn't in MultiWorlds mode, this is the IID of the internal "dummy" World.
     */
    char * dummy_world_iid;
    /**
     * If TRUE, the exported PNGs will include the level background (color or image).
     */
    bool export_level_bg;
    /**
     * **WARNING**: this deprecated value is no longer exported since version 0.9.3  Replaced
     * by: `imageExportMode`
     */
    bool * export_png;
    /**
     * If TRUE, a Tiled compatible file will also be generated along with the LDtk JSON file
     * (default is FALSE)
     */
    bool export_tiled;
    /**
     * If TRUE, one file will be saved for the project (incl. all its definitions) and one file
     * in a sub-folder for each level.
     */
    bool external_levels;
    /**
     * An array containing various advanced flags (ie. options or other states). Possible
     * values: `DiscardPreCsvIntGrid`, `ExportPreCsvIntGridFormat`, `IgnoreBackupSuggest`,
     * `PrependIndexToLevelFileNames`, `MultiWorlds`, `UseMultilinesType`
     */
    list_t * flags;
    /**
     * Naming convention for Identifiers (first-letter uppercase, full uppercase etc.) Possible
     * values: `Capitalize`, `Uppercase`, `Lowercase`, `Free`
     */
    enum IdentifierStyle identifier_style;
    /**
     * Unique project identifier
     */
    char * iid;
    /**
     * "Image export" option when saving project. Possible values: `None`, `OneImagePerLayer`,
     * `OneImagePerLevel`, `LayersAndLevels`
     */
    enum ImageExportMode image_export_mode;
    /**
     * File format version
     */
    char * json_version;
    /**
     * The default naming convention for level identifiers.
     */
    char * level_name_pattern;
    /**
     * All levels. The order of this array is only relevant in `LinearHorizontal` and
     * `linearVertical` world layouts (see `worldLayout` value).<br/>  Otherwise, you should
     * refer to the `worldX`,`worldY` coordinates of each Level.
     */
    list_t * levels;
    /**
     * If TRUE, the Json is partially minified (no indentation, nor line breaks, default is
     * FALSE)
     */
    bool minify_json;
    /**
     * Next Unique integer ID available
     */
    int64_t next_uid;
    /**
     * File naming pattern for exported PNGs
     */
    char * png_file_pattern;
    /**
     * If TRUE, a very simplified will be generated on saving, for quicker & easier engine
     * integration.
     */
    bool simplified_export;
    /**
     * All instances of entities that have their `exportToToc` flag enabled are listed in this
     * array.
     */
    list_t * toc;
    /**
     * This optional description is used by LDtk Samples to show up some informations and
     * instructions.
     */
    char * tutorial_desc;
    /**
     * **WARNING**: this field will move to the `worlds` array after the "multi-worlds" update.
     * It will then be `null`. You can enable the Multi-worlds advanced project option to enable
     * the change immediately.<br/><br/>  Height of the world grid in pixels.
     */
    int64_t * world_grid_height;
    /**
     * **WARNING**: this field will move to the `worlds` array after the "multi-worlds" update.
     * It will then be `null`. You can enable the Multi-worlds advanced project option to enable
     * the change immediately.<br/><br/>  Width of the world grid in pixels.
     */
    int64_t * world_grid_width;
    /**
     * **WARNING**: this field will move to the `worlds` array after the "multi-worlds" update.
     * It will then be `null`. You can enable the Multi-worlds advanced project option to enable
     * the change immediately.<br/><br/>  An enum that describes how levels are organized in
     * this project (ie. linearly or in a 2D space). Possible values: &lt;`null`&gt;, `Free`,
     * `GridVania`, `LinearHorizontal`, `LinearVertical`
     */
    enum WorldLayout * world_layout;
    /**
     * This array will be empty, unless you enable the Multi-Worlds in the project advanced
     * settings.<br/><br/> - in current version, a LDtk project file can only contain a single
     * world with multiple levels in it. In this case, levels and world layout related settings
     * are stored in the root of the JSON.<br/> - with "Multi-worlds" enabled, there will be a
     * `worlds` array in root, each world containing levels and layout settings. Basically, it's
     * pretty much only about moving the `levels` array to the `worlds` array, along with world
     * layout related values (eg. `worldGridWidth` etc).<br/><br/>If you want to start
     * supporting this future update easily, please refer to this documentation:
     * https://github.com/deepnight/ldtk/issues/231
     */
    list_t * worlds;
};

enum When cJSON_GetWhenValue(const cJSON * j);
cJSON * cJSON_CreateWhen(const enum When x);

enum AllowedRefs cJSON_GetAllowedRefsValue(const cJSON * j);
cJSON * cJSON_CreateAllowedRefs(const enum AllowedRefs x);

enum EditorDisplayMode cJSON_GetEditorDisplayModeValue(const cJSON * j);
cJSON * cJSON_CreateEditorDisplayMode(const enum EditorDisplayMode x);

enum EditorDisplayPos cJSON_GetEditorDisplayPosValue(const cJSON * j);
cJSON * cJSON_CreateEditorDisplayPos(const enum EditorDisplayPos x);

enum EditorLinkStyle cJSON_GetEditorLinkStyleValue(const cJSON * j);
cJSON * cJSON_CreateEditorLinkStyle(const enum EditorLinkStyle x);

enum TextLanguageMode cJSON_GetTextLanguageModeValue(const cJSON * j);
cJSON * cJSON_CreateTextLanguageMode(const enum TextLanguageMode x);

enum LimitBehavior cJSON_GetLimitBehaviorValue(const cJSON * j);
cJSON * cJSON_CreateLimitBehavior(const enum LimitBehavior x);

enum LimitScope cJSON_GetLimitScopeValue(const cJSON * j);
cJSON * cJSON_CreateLimitScope(const enum LimitScope x);

enum RenderMode cJSON_GetRenderModeValue(const cJSON * j);
cJSON * cJSON_CreateRenderMode(const enum RenderMode x);

enum TileRenderMode cJSON_GetTileRenderModeValue(const cJSON * j);
cJSON * cJSON_CreateTileRenderMode(const enum TileRenderMode x);

enum Checker cJSON_GetCheckerValue(const cJSON * j);
cJSON * cJSON_CreateChecker(const enum Checker x);

enum TileMode cJSON_GetTileModeValue(const cJSON * j);
cJSON * cJSON_CreateTileMode(const enum TileMode x);

enum Type cJSON_GetTypeValue(const cJSON * j);
cJSON * cJSON_CreateType(const enum Type x);

enum EmbedAtlas cJSON_GetEmbedAtlasValue(const cJSON * j);
cJSON * cJSON_CreateEmbedAtlas(const enum EmbedAtlas x);

enum Flag cJSON_GetFlagValue(const cJSON * j);
cJSON * cJSON_CreateFlag(const enum Flag x);

enum BgPos cJSON_GetBgPosValue(const cJSON * j);
cJSON * cJSON_CreateBgPos(const enum BgPos x);

enum WorldLayout cJSON_GetWorldLayoutValue(const cJSON * j);
cJSON * cJSON_CreateWorldLayout(const enum WorldLayout x);

enum IdentifierStyle cJSON_GetIdentifierStyleValue(const cJSON * j);
cJSON * cJSON_CreateIdentifierStyle(const enum IdentifierStyle x);

enum ImageExportMode cJSON_GetImageExportModeValue(const cJSON * j);
cJSON * cJSON_CreateImageExportMode(const enum ImageExportMode x);

struct LdtkCustomCommand * cJSON_ParseLdtkCustomCommand(const char * s);
struct LdtkCustomCommand * cJSON_GetLdtkCustomCommandValue(const cJSON * j);
cJSON * cJSON_CreateLdtkCustomCommand(const struct LdtkCustomCommand * x);
char * cJSON_PrintLdtkCustomCommand(const struct LdtkCustomCommand * x);
void cJSON_DeleteLdtkCustomCommand(struct LdtkCustomCommand * x);

struct FieldDefinition * cJSON_ParseFieldDefinition(const char * s);
struct FieldDefinition * cJSON_GetFieldDefinitionValue(const cJSON * j);
cJSON * cJSON_CreateFieldDefinition(const struct FieldDefinition * x);
char * cJSON_PrintFieldDefinition(const struct FieldDefinition * x);
void cJSON_DeleteFieldDefinition(struct FieldDefinition * x);

struct TilesetRectangle * cJSON_ParseTilesetRectangle(const char * s);
struct TilesetRectangle * cJSON_GetTilesetRectangleValue(const cJSON * j);
cJSON * cJSON_CreateTilesetRectangle(const struct TilesetRectangle * x);
char * cJSON_PrintTilesetRectangle(const struct TilesetRectangle * x);
void cJSON_DeleteTilesetRectangle(struct TilesetRectangle * x);

struct EntityDefinition * cJSON_ParseEntityDefinition(const char * s);
struct EntityDefinition * cJSON_GetEntityDefinitionValue(const cJSON * j);
cJSON * cJSON_CreateEntityDefinition(const struct EntityDefinition * x);
char * cJSON_PrintEntityDefinition(const struct EntityDefinition * x);
void cJSON_DeleteEntityDefinition(struct EntityDefinition * x);

struct EnumValueDefinition * cJSON_ParseEnumValueDefinition(const char * s);
struct EnumValueDefinition * cJSON_GetEnumValueDefinitionValue(const cJSON * j);
cJSON * cJSON_CreateEnumValueDefinition(const struct EnumValueDefinition * x);
char * cJSON_PrintEnumValueDefinition(const struct EnumValueDefinition * x);
void cJSON_DeleteEnumValueDefinition(struct EnumValueDefinition * x);

struct EnumDefinition * cJSON_ParseEnumDefinition(const char * s);
struct EnumDefinition * cJSON_GetEnumDefinitionValue(const cJSON * j);
cJSON * cJSON_CreateEnumDefinition(const struct EnumDefinition * x);
char * cJSON_PrintEnumDefinition(const struct EnumDefinition * x);
void cJSON_DeleteEnumDefinition(struct EnumDefinition * x);

struct AutoLayerRuleDefinition * cJSON_ParseAutoLayerRuleDefinition(const char * s);
struct AutoLayerRuleDefinition * cJSON_GetAutoLayerRuleDefinitionValue(const cJSON * j);
cJSON * cJSON_CreateAutoLayerRuleDefinition(const struct AutoLayerRuleDefinition * x);
char * cJSON_PrintAutoLayerRuleDefinition(const struct AutoLayerRuleDefinition * x);
void cJSON_DeleteAutoLayerRuleDefinition(struct AutoLayerRuleDefinition * x);

struct AutoLayerRuleGroup * cJSON_ParseAutoLayerRuleGroup(const char * s);
struct AutoLayerRuleGroup * cJSON_GetAutoLayerRuleGroupValue(const cJSON * j);
cJSON * cJSON_CreateAutoLayerRuleGroup(const struct AutoLayerRuleGroup * x);
char * cJSON_PrintAutoLayerRuleGroup(const struct AutoLayerRuleGroup * x);
void cJSON_DeleteAutoLayerRuleGroup(struct AutoLayerRuleGroup * x);

struct IntGridValueDefinition * cJSON_ParseIntGridValueDefinition(const char * s);
struct IntGridValueDefinition * cJSON_GetIntGridValueDefinitionValue(const cJSON * j);
cJSON * cJSON_CreateIntGridValueDefinition(const struct IntGridValueDefinition * x);
char * cJSON_PrintIntGridValueDefinition(const struct IntGridValueDefinition * x);
void cJSON_DeleteIntGridValueDefinition(struct IntGridValueDefinition * x);

struct IntGridValueGroupDefinition * cJSON_ParseIntGridValueGroupDefinition(const char * s);
struct IntGridValueGroupDefinition * cJSON_GetIntGridValueGroupDefinitionValue(const cJSON * j);
cJSON * cJSON_CreateIntGridValueGroupDefinition(const struct IntGridValueGroupDefinition * x);
char * cJSON_PrintIntGridValueGroupDefinition(const struct IntGridValueGroupDefinition * x);
void cJSON_DeleteIntGridValueGroupDefinition(struct IntGridValueGroupDefinition * x);

struct LayerDefinition * cJSON_ParseLayerDefinition(const char * s);
struct LayerDefinition * cJSON_GetLayerDefinitionValue(const cJSON * j);
cJSON * cJSON_CreateLayerDefinition(const struct LayerDefinition * x);
char * cJSON_PrintLayerDefinition(const struct LayerDefinition * x);
void cJSON_DeleteLayerDefinition(struct LayerDefinition * x);

struct TileCustomMetadata * cJSON_ParseTileCustomMetadata(const char * s);
struct TileCustomMetadata * cJSON_GetTileCustomMetadataValue(const cJSON * j);
cJSON * cJSON_CreateTileCustomMetadata(const struct TileCustomMetadata * x);
char * cJSON_PrintTileCustomMetadata(const struct TileCustomMetadata * x);
void cJSON_DeleteTileCustomMetadata(struct TileCustomMetadata * x);

struct EnumTagValue * cJSON_ParseEnumTagValue(const char * s);
struct EnumTagValue * cJSON_GetEnumTagValueValue(const cJSON * j);
cJSON * cJSON_CreateEnumTagValue(const struct EnumTagValue * x);
char * cJSON_PrintEnumTagValue(const struct EnumTagValue * x);
void cJSON_DeleteEnumTagValue(struct EnumTagValue * x);

struct TilesetDefinition * cJSON_ParseTilesetDefinition(const char * s);
struct TilesetDefinition * cJSON_GetTilesetDefinitionValue(const cJSON * j);
cJSON * cJSON_CreateTilesetDefinition(const struct TilesetDefinition * x);
char * cJSON_PrintTilesetDefinition(const struct TilesetDefinition * x);
void cJSON_DeleteTilesetDefinition(struct TilesetDefinition * x);

struct Definitions * cJSON_ParseDefinitions(const char * s);
struct Definitions * cJSON_GetDefinitionsValue(const cJSON * j);
cJSON * cJSON_CreateDefinitions(const struct Definitions * x);
char * cJSON_PrintDefinitions(const struct Definitions * x);
void cJSON_DeleteDefinitions(struct Definitions * x);

struct FieldInstance * cJSON_ParseFieldInstance(const char * s);
struct FieldInstance * cJSON_GetFieldInstanceValue(const cJSON * j);
cJSON * cJSON_CreateFieldInstance(const struct FieldInstance * x);
char * cJSON_PrintFieldInstance(const struct FieldInstance * x);
void cJSON_DeleteFieldInstance(struct FieldInstance * x);

struct EntityInstance * cJSON_ParseEntityInstance(const char * s);
struct EntityInstance * cJSON_GetEntityInstanceValue(const cJSON * j);
cJSON * cJSON_CreateEntityInstance(const struct EntityInstance * x);
char * cJSON_PrintEntityInstance(const struct EntityInstance * x);
void cJSON_DeleteEntityInstance(struct EntityInstance * x);

struct ReferenceToAnEntityInstance * cJSON_ParseReferenceToAnEntityInstance(const char * s);
struct ReferenceToAnEntityInstance * cJSON_GetReferenceToAnEntityInstanceValue(const cJSON * j);
cJSON * cJSON_CreateReferenceToAnEntityInstance(const struct ReferenceToAnEntityInstance * x);
char * cJSON_PrintReferenceToAnEntityInstance(const struct ReferenceToAnEntityInstance * x);
void cJSON_DeleteReferenceToAnEntityInstance(struct ReferenceToAnEntityInstance * x);

struct GridPoint * cJSON_ParseGridPoint(const char * s);
struct GridPoint * cJSON_GetGridPointValue(const cJSON * j);
cJSON * cJSON_CreateGridPoint(const struct GridPoint * x);
char * cJSON_PrintGridPoint(const struct GridPoint * x);
void cJSON_DeleteGridPoint(struct GridPoint * x);

struct IntGridValueInstance * cJSON_ParseIntGridValueInstance(const char * s);
struct IntGridValueInstance * cJSON_GetIntGridValueInstanceValue(const cJSON * j);
cJSON * cJSON_CreateIntGridValueInstance(const struct IntGridValueInstance * x);
char * cJSON_PrintIntGridValueInstance(const struct IntGridValueInstance * x);
void cJSON_DeleteIntGridValueInstance(struct IntGridValueInstance * x);

struct TileInstance * cJSON_ParseTileInstance(const char * s);
struct TileInstance * cJSON_GetTileInstanceValue(const cJSON * j);
cJSON * cJSON_CreateTileInstance(const struct TileInstance * x);
char * cJSON_PrintTileInstance(const struct TileInstance * x);
void cJSON_DeleteTileInstance(struct TileInstance * x);

struct LayerInstance * cJSON_ParseLayerInstance(const char * s);
struct LayerInstance * cJSON_GetLayerInstanceValue(const cJSON * j);
cJSON * cJSON_CreateLayerInstance(const struct LayerInstance * x);
char * cJSON_PrintLayerInstance(const struct LayerInstance * x);
void cJSON_DeleteLayerInstance(struct LayerInstance * x);

struct LevelBackgroundPosition * cJSON_ParseLevelBackgroundPosition(const char * s);
struct LevelBackgroundPosition * cJSON_GetLevelBackgroundPositionValue(const cJSON * j);
cJSON * cJSON_CreateLevelBackgroundPosition(const struct LevelBackgroundPosition * x);
char * cJSON_PrintLevelBackgroundPosition(const struct LevelBackgroundPosition * x);
void cJSON_DeleteLevelBackgroundPosition(struct LevelBackgroundPosition * x);

struct NeighbourLevel * cJSON_ParseNeighbourLevel(const char * s);
struct NeighbourLevel * cJSON_GetNeighbourLevelValue(const cJSON * j);
cJSON * cJSON_CreateNeighbourLevel(const struct NeighbourLevel * x);
char * cJSON_PrintNeighbourLevel(const struct NeighbourLevel * x);
void cJSON_DeleteNeighbourLevel(struct NeighbourLevel * x);

struct Level * cJSON_ParseLevel(const char * s);
struct Level * cJSON_GetLevelValue(const cJSON * j);
cJSON * cJSON_CreateLevel(const struct Level * x);
char * cJSON_PrintLevel(const struct Level * x);
void cJSON_DeleteLevel(struct Level * x);

struct LdtkTableOfContentEntry * cJSON_ParseLdtkTableOfContentEntry(const char * s);
struct LdtkTableOfContentEntry * cJSON_GetLdtkTableOfContentEntryValue(const cJSON * j);
cJSON * cJSON_CreateLdtkTableOfContentEntry(const struct LdtkTableOfContentEntry * x);
char * cJSON_PrintLdtkTableOfContentEntry(const struct LdtkTableOfContentEntry * x);
void cJSON_DeleteLdtkTableOfContentEntry(struct LdtkTableOfContentEntry * x);

struct World * cJSON_ParseWorld(const char * s);
struct World * cJSON_GetWorldValue(const cJSON * j);
cJSON * cJSON_CreateWorld(const struct World * x);
char * cJSON_PrintWorld(const struct World * x);
void cJSON_DeleteWorld(struct World * x);

struct ForcedRefs * cJSON_ParseForcedRefs(const char * s);
struct ForcedRefs * cJSON_GetForcedRefsValue(const cJSON * j);
cJSON * cJSON_CreateForcedRefs(const struct ForcedRefs * x);
char * cJSON_PrintForcedRefs(const struct ForcedRefs * x);
void cJSON_DeleteForcedRefs(struct ForcedRefs * x);

struct LDtk * cJSON_ParseLDtk(const char * s);
struct LDtk * cJSON_GetLDtkValue(const cJSON * j);
cJSON * cJSON_CreateLDtk(const struct LDtk * x);
char * cJSON_PrintLDtk(const struct LDtk * x);
void cJSON_DeleteLDtk(struct LDtk * x);

#ifdef __cplusplus
}
#endif

#endif /* LDTK_H */
